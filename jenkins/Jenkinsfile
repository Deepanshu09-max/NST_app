pipeline {
  agent any

  environment {
    GITHUB_REPO_URL         = 'https://github.com/Deepanshu09-max/NST_app.git'
    GIT_BRANCH              = 'devops'
    DOCKER_CREDS            = 'dockerhub-credentials'
    KUBECONFIG_CRED         = 'minikube-kubeconfig'
    FINE_TUNE_JOB           = 'NST_Fine_Tune_Job'
    BAD_FEEDBACK_THRESHOLD  = 5
    HOST_PERSISTENT_STORAGE = '/home/deepanshu/Documents/SPE Major/NST_app/persistent_storage'
  }

  options {
    timestamps()
    buildDiscarder(logRotator(numToKeepStr: '10'))
  }

  stages {
    stage('Pre-flight: Docker login & Kubeconfig') {
      steps {
        withCredentials([usernamePassword(
          credentialsId: "${DOCKER_CREDS}",
          usernameVariable: 'DOCKER_USER',
          passwordVariable: 'DOCKER_PASS'
        )]) {
          sh '''
            echo "$DOCKER_PASS" | docker login -u "$DOCKER_USER" --password-stdin
          '''
        }
        withCredentials([file(
          credentialsId: "${KUBECONFIG_CRED}",
          variable: 'KUBE_CONFIG'
        )]) {
          sh '''
            export KUBECONFIG=$KUBE_CONFIG
            echo "üõ†Ô∏è  Using KUBECONFIG from Jenkins credentials"
            kubectl version --client
          '''
        }
      }
    }

    stage('Checkout') {
      steps {
        git branch: "${GIT_BRANCH}", url: "${GITHUB_REPO_URL}"
      }
    }
    stage('Wipe Conflicting Containers') {
      steps {
        sh '''
          echo "--- Checking for containers publishing your ports ---"
          docker ps --format '{{.ID}} {{.Names}} {{.Ports}}' \
            | grep -E '8080->|800[0-5]->' || echo "üëç No conflicts found"
    
          echo "--- Removing any conflicting containers ---"
          # Find any container bound to 80,8000‚Äì8005
          docker ps -q --filter "publish=80" \
            --filter "publish=8000" \
            --filter "publish=8001" \
            --filter "publish=8002" \
            --filter "publish=8003" \
            --filter "publish=8004" \
            --filter "publish=8005" \
          | xargs --no-run-if-empty docker rm -f
    
          echo "--- Done cleaning up port-binding containers ---"
        '''
      }
    }
    stage('Pre-Compose Cleanup') {
      steps {
        sh '''
          echo "üßπ Tear down any old compose stacks (both named & default)‚Ä¶"
          # Named (project = nstapp)
          docker-compose -p nstapp -f docker-compose.yml down -v --remove-orphans || true
          # Default (project = working-dir basename)
          docker-compose          -f docker-compose.yml down -v --remove-orphans || true
    
          echo "üßπ Remove stray containers by name prefix"
          docker ps -a --filter "name=^/nstapp_" -q \
            | xargs --no-run-if-empty docker rm -f
    
          echo "üßπ Kill anything still listening on port 8080"
          # If it's a Docker container: remove it
          docker ps -q --filter publish=8080 \
            | xargs --no-run-if-empty docker rm -f
          # If it's any process: kill it
          lsof -i :8080 -t \
            | xargs --no-run-if-empty kill -9
    
          echo "üßπ Prune unused images, networks, volumes"
          docker network prune -f
          docker system prune -af
    
          echo "üîß Reset workspace persistent_storage folder"
          sudo rm -rf persistent_storage
          mkdir -p persistent_storage
        '''
      }
    }
    
    stage('Mount persistent_storage & Enable Ingress in Minikube') {
      steps {
        sh """
          SRC=\"${HOST_PERSISTENT_STORAGE}\"
    
          echo "‚ñ∂ Killing any prior minikube mount processes"
          pkill -f 'minikube mount' || true
    
          echo "‚Üí Verifying host-folder exists and is accessible"
          ls -ld "\${SRC}" || { echo "‚ùå \${SRC} not found"; exit 1; }
    
          echo "‚Üí Checking Minikube status (host component only)"
          if ! minikube status --format='{{.Host}}' | grep -q "Running"; then
            echo "‚Üí Minikube not running; starting with Docker driver‚Ä¶"
            minikube delete
            minikube start --driver=docker
          else
            echo "‚Üí Minikube is already running."
          fi
    
          echo "‚ñ∂ Mounting \"\${SRC}\" ‚Üí Minikube:/persistent_storage"
          nohup minikube mount "\${SRC}":/persistent_storage \
                --uid=\$(id -u) --gid=\$(id -g) \
                > minikube-mount.log 2>&1 &
    
          sleep 5
    
          echo "‚ñ∂ Checking minikube-mount is up"
          if pgrep -f 'minikube mount' > /dev/null; then
            echo "‚úî mount OK (PID=\$(pgrep -f 'minikube mount'))"
          else
            echo "‚ùå mount failed; logs:"
            cat minikube-mount.log || echo "Log empty or not found"
            exit 1
          fi
    
          echo "‚ñ∂ Enabling Ingress addon (in background; not blocking)‚Ä¶"
          nohup minikube addons enable ingress \
                > minikube-ingress-enable.log 2>&1 &
    
          echo "‚ÑπÔ∏è Ingress enable kicked off; continuing without wait."
        """
      }
    }
    
    
        
        

    stage('Debug: Compose Config & Networks') {
      steps {
        sh '''
          echo "--- Effective Compose Configuration ---"
          docker network ls | grep nstapp_app_network || true
          docker-compose -p nstapp -f docker-compose.yml config
          echo
          echo "--- Docker Networks ---"
          docker network ls
        '''
      }
    }



   stage('Build & Up Services (Docker-Compose)') {
      steps {
        sh '''
          echo "üöÄ Building & launching all services under project 'nstapp'‚Ä¶"
    
          echo "--- Networks just before up ---"
          docker network ls
          echo "‚ñ∂ Proceeding with Docker Compose up & build"
          docker-compose -p nstapp -f docker-compose.yml up -d --build
    
          echo "‚úÖ Post-up network check for 'nstapp_app_network'"
          docker network ls | grep nstapp_app_network || echo "‚ö†Ô∏è Network not found"
          docker ps  | grep inference_service_model
          docker logs nstapp_inference_service_model1_1

        '''
      }
    }

    stage('Integration Tests') {
      steps {
        sh '''
          echo "‚ñ∂ Running integration tests"
          python3 test.py || true
        '''
      }
    }

    stage('Tag & Push Images') {
      steps {
        withCredentials([usernamePassword(
          credentialsId: "${DOCKER_CREDS}",
          usernameVariable: 'DOCKER_USER',
          passwordVariable: 'DOCKER_PASS'
        )]) {
          sh '''
            echo "$DOCKER_PASS" | docker login -u "$DOCKER_USER" --password-stdin

            for svc in \
              base-tf \
              frontend \
              routing_service \
              fine_tuning_service \
              inference_service_model1 \
              inference_service_model2 \
              inference_service_model3 \
              inference_service_model4; do

              echo "üîñ Tag & push nst_app_${svc}:latest ‚Üí $DOCKER_USER/nst_app:${svc}"
              docker tag nst_app_${svc}:latest $DOCKER_USER/nst_app:${svc}
              docker push $DOCKER_USER/nst_app:${svc}
            done
          '''
        }
      }
    }

    stage('Deploy to K8s & ELK (Ansible)') {
      steps {
        sh '''
          export KUBECONFIG=$KUBE_CONFIG
          cd ansible/playbooks
          ansible-playbook -i ../inventory.ini umbrella-playbook.yml
        '''
      }
    }

    stage('Check Feedback & Trigger Fine-Tuning') {
      steps {
        script {
          // Paths to files
          def fbFile     = "${env.HOST_PERSISTENT_STORAGE}/feedback.jsonl"
          def offsetFile = "${env.HOST_PERSISTENT_STORAGE}/feedback.offset"
          def countsFile = "${env.HOST_PERSISTENT_STORAGE}/feedback.counts.json"
    
          // 1) Verify feedback.jsonl exists
          echo "üîç [DEBUG] Looking for feedback file at: ${fbFile}"
          if (!fileExists(fbFile)) {
            echo "‚ÑπÔ∏è  No feedback file found at '${fbFile}' ‚Üí skipping fine-tune check."
            return
          }
    
          // 2) Read all lines from feedback.jsonl
          def allLines = []
          try {
            allLines = readFile(fbFile).readLines()
          } catch (err) {
            echo "‚ùå  Failed to read '${fbFile}': ${err.getMessage()}"
            return
          }
          def totalLines = allLines.size()
          echo "üîç [DEBUG] totalLines = ${totalLines}"
    
          // 3) Determine last offset (default to 0 if missing/invalid)
          int offsetValue = 0
          if (fileExists(offsetFile)) {
            try {
              offsetValue = readFile(offsetFile).trim().toInteger()
              echo "üîç [DEBUG] Parsed offsetValue = ${offsetValue}"
            } catch (Exception e) {
              echo "‚ö†Ô∏è  Invalid offset in '${offsetFile}'; resetting to 0."
              offsetValue = 0
            }
          } else {
            echo "üîç [DEBUG] No offset file at '${offsetFile}'; defaulting offsetValue = 0"
          }
    
          // Reset offset if larger than total
          if (offsetValue > totalLines) {
            echo "‚ö†Ô∏è  offsetValue (${offsetValue}) > totalLines (${totalLines}); resetting offset ‚Üí 0"
            offsetValue = 0
          }
    
          // 4) If no new lines, update offset and exit
          if (totalLines <= offsetValue) {
            echo "‚úÖ  No new feedback (offset=${offsetValue}, totalLines=${totalLines})."
            writeFile file: offsetFile, text: totalLines.toString()
            echo "üîç [DEBUG] Wrote new offset (${totalLines}) to '${offsetFile}'"
            return
          }
    
          // 5) Compute newLines array
          def newLines = allLines[offsetValue..<totalLines]
          echo "‚ÑπÔ∏è  Found ${newLines.size()} new line(s) of feedback"
    
          // 6) Load existing cumulative ‚Äúbad‚Äù counts
          def cumulativeCounts = [:]
          if (fileExists(countsFile)) {
            try {
              cumulativeCounts = readJSON file: countsFile
              echo "üîç [DEBUG] Loaded cumulativeCounts = ${cumulativeCounts}"
            } catch (Exception e) {
              echo "‚ö†Ô∏è  Could not parse '${countsFile}'; initializing all counts to 0."
              cumulativeCounts = [:]
            }
          } else {
            echo "üîç [DEBUG] No counts file at '${countsFile}'; initializing all counts to 0."
          }
    
          // 7) Count ‚Äúbad‚Äù feedback in newLines per model
          def newBadCounts = [:]   // plain map
    
          newLines.eachWithIndex { line, idx ->
            def text = line?.trim()
            if (!text) {
              echo "‚ö†Ô∏è  newLines[${idx}] empty or whitespace, skipping"
              return
            }
            try {
              echo "üîç [DEBUG] Parsing JSON on newLines[${idx}]"
              def json = readJSON text: text
              echo "üîç [DEBUG] Parsed: feedback='${json.feedback}', model='${json.model}'"
              if (json.feedback == 'bad' && json.model) {
                def prev = newBadCounts.containsKey(json.model) ? newBadCounts[json.model] : 0
                newBadCounts[json.model] = prev + 1
              }
            } catch (Exception e) {
              echo "‚ùå  JSON parse error on newLines[${idx}]: ${e.toString()}"
            }
          }
    
          // 8) Merge into cumulativeCounts and decide triggers
          def threshold = env.BAD_FEEDBACK_THRESHOLD.toInteger()
          def toTrigger = []
          newBadCounts.each { model, badThisRun ->
            def oldCount = cumulativeCounts.containsKey(model) ? (cumulativeCounts[model] as Integer) : 0
            def updated  = oldCount + badThisRun
            cumulativeCounts[model] = updated
            echo "üìä  Model='${model}', oldBad=${oldCount}, newBad=${badThisRun}, totalBad=${updated}"
            if (updated >= threshold) {
              toTrigger << model
            }
          }
    
          // 9) Trigger fine-tune for any model that hit threshold, then reset its count
          def anyTriggered = false
          toTrigger.unique().each { model ->
            echo "‚ñ∂ Triggering fine-tune for '${model}'"
            build job: "${FINE_TUNE_JOB}",
                  wait: false,
                  parameters: [
                    string(name: 'BAD_FEEDBACK_COUNT', value: cumulativeCounts[model].toString()),
                    string(name: 'MODEL_NAME',         value: model)
                  ]
            cumulativeCounts[model] = 0
            echo "‚ÑπÔ∏è  Reset cumulativeCounts['${model}'] ‚Üí 0"
            anyTriggered = true
          }
    
          if (!anyTriggered) {
            echo "‚úÖ  No model exceeded threshold (${threshold}); no fine-tune triggered."
          }
    
          // 10) Write updated counts back (no pretty flag)
          writeJSON file: countsFile, json: cumulativeCounts
          echo "üîç [DEBUG] Wrote updated cumulativeCounts to '${countsFile}': ${cumulativeCounts}"
    
          // 11) Update offset
          writeFile file: offsetFile, text: totalLines.toString()
          echo "üîç [DEBUG] Updated '${offsetFile}' to ${totalLines}"
        } // end script
      }   // end steps
    }     // end stage
}

  post {
    success {
      echo '‚úÖ Pipeline completed successfully.'
    }
    failure {
      echo '‚ùå Pipeline failed ‚Äî please inspect the logs.'
    }
    always {
      sh '''
        echo "üßπ Cleaning up: Docker & Minikube mounts"
        docker-compose -p nstapp -f docker-compose.yml down --remove-orphans
        docker system prune -af || true
        docker network prune -f

        echo "‚ñ∂ Killing minikube mount"
        pkill -f "minikube mount" || true
      '''
    }
  }
}
